---
layout: post
title: "Signs that you're a bad programmer/不好的程序员的迹象（翻译）"
description: ""
category: 
tags: []
---
{% include JB/setup %}


原文地址：http://www.yacoset.com/Home/signs-that-you-re-a-bad-programmer

1.无力推理代码

推理代码意味着能够跟随程序的运作（“运行程序在你的头脑中”），清楚的了解代码的目标是什么。

###症状

1."voodoo code"，代码的存在对目标没有影响，无论如何维护（如初始化从未使用的变量，调用函数不相关的目标  ，产生未使用的输出等）

2.执行幂等的函数多次（如：调用save()函数多次“只是想确定被调用”）

3.通过覆盖代码修复bug而产生更多的缺陷代码

4.“Yo-Yo code”，将一个值转换成不同的表现，然后将其转回来（比如：将一个十进制数转换成字符串，然后获取小数位，或填充一个字符串，然后修剪它）

5.“推土机代码（Bulldozer code）”，重构之后的代码仅仅看起来低耦合，但是依然不能够重用（非常高内聚）

###补救措施

为了克服这一缺陷程序员可以使用IDE的调试器作为助手，如果它可以深入代码一行一停的调试。在Visual Studio中，例如，这意味着设置一个断点在问题区域的开始，并与“F11”键步进通过，检查变量的值 - 之前，他们改变后， - 直到你明白的代码是什么这样做。如果目标环境中不具备这样的功能，那就去换个IDE带这个功能的。

我们的目标是要达到你不再需要调试器来调试代码，而是你大脑能够跟随代码的运行，当你有足够的耐心去思考到底是在对程序做什么，你就能找出多余的，不必要的代码，以及如何找到现有代码中的bug，而不必常规从头开始实现。

###2.对编程语言的模型缺乏了解

面向对象编程（Object Oriented Programming ）是一种语言模型，是功能性或声明性编程。他们显著不同于的程序式或命令式编程，就如同过程编程是和组件编程或GOTO为基础的编程有显著的不同方案。再就是它遵循的一个主要的编程模型（如OOP），但介绍自己的改进，一个列表的自我理解实现如，范型，duck-typing等。

###症状

1.使用任何必要的语法来破坏模型，然后剩下的程序用熟悉语言风格来写
2.（OOP）尝试调用非静态函数或变量在非实例类，难于理解为什么它会编译失败
3.（OOP）写个“xxxxxManager”类包含所有的方法用于操作字段，但是这些字段只有部分是这个对象所有的
4.（关系）在客户端代码中，把关系数据库作为一个对象存储和执行，
5.（功能）创建多个版本相同的算法来处理不同类型或操作，而不是通过high-level方法通用范型的实现
6.（功能）手动缓存一个其他平台可以自动处理缓存的结果集
7.复制粘贴代码来操作I／O
8.（声明）设置只对个人有价值的命令式代码，而不是使用数据绑定

###补救措施

如果你的技能缺乏无效的教学或学习的产品，那么替代的老师就是编译器本身。没有比学习开始一个新项目，使用任何新的结构，与新的编程模型的更有效的方法。您还需要在紧张并且混乱的实践中解释模型的各个方面无论你是否熟悉，重复构建你的语汇，直到你明白的细微之处，以及模型的特点。例如：

第1阶段：“面向对象仅仅是记录与方法”
第2阶段：“面向对象的方法是在一个有自己的全局变量的小程序中运行”
第3阶段：“全局变量被称为字段，其中有一些是私有的，对其他小程序是不可见的”
第4阶段：“有私有和公共元素的想法是隐藏实现细节，暴露出一个干净的接口，这就是所谓的封装”
第5阶段：“封装意味着我的商业逻辑不会在被实现新的细节当中改变”

第5阶段看起来相同的所有语言，因为它们都真的试图让程序员在那里，他可以表达程序的意图，而不把它埋在如何具体点。以函数式编程的另一个例子：

第一阶段：“函数式编程只是做一切通过链接确定性函数在一起”
第2阶段：“当函数是确定性的编译器可以预测它什么时候可以缓存结果或跳过的评价，甚至当它是安全的提前停止评价”
第3阶段：“为了支持延迟和部分评估，编译器需要的功能在如何将单个参数术语定义，有时到另一个函数这就是所谓柯里化。”
第四阶段：“有时，编译器可以做柯里为我”
第5阶段：“通过让编译器的身影走出世俗的细节，我可以写通过描述我想要什么，而不是如何给我的方案”

该平台的功能缺陷3.研究技能/长期贫困的知识

现代语言和框架，现在配备了一个真棒广度和内置的命令和功能的深度，与一些领先的框架（Java，.NET，可可）是太大期望任何程序员，甚至是一个很好的，学习的东西少比几年。但是，一个好的程序员将搜索内置函数，满足他们的需要开始推出自己的才，和优秀的程序员的技能，击穿并确定他们的任务抽象的问题，然后搜索现有的框架，模式，模型和语言可以适于之前，他们甚至开始设计方案。

症状

这些，如果他们继续出现在程序员的工作后不久，他应该已经掌握了新的平台只是象征的问题。

重新发明或劳动没有被内置到语言的基本机制，例如事件和 - 处理或正则表达式
重新发明类和被内置到框架功能（例如：定时器，集合，排序和搜索算法）*
“电子邮件me德代码，PLZ”的消息发布到帮助论坛
“回旋码”是在完成许多指令什么可以用少得多的工作要做（例如：通过转换成十进制格式的字符串，然后转换成字符串返回到小数点四舍五入数字）
坚持用老式的方法，即使新技术是在这些情况下更好的（如：还是写，而不是使用lambda表达式命名的委托功能）
具有鲜明的“舒适区”，并打算极端的长度，以解决复杂问题的原语
* - 意外的重复也会发生，适度的框架由度的大小，因此判断。有人谁手掷出链表可能知道他们在做什么，但有人谁手推出自己的strcpy（）可能不会。

补救措施

而不会减慢程序员无法获得这种知识，而且很可能是他一直在匆忙通过一切必要手段来获得各功能工作。他需要有平台的技术参考得心应手，能够期待通过它以最小的努力，这可能意味着要么有它的硬拷贝在书桌上旁边的键盘，或具有第二显示器专用于浏览器。要进入这个习惯最初，他应该重构他的老代码由10降低其指令计数的目标：1以上。

4.无力理解指针

如果你不明白指针则对节目你可以写一个类型很浅的上限，作为指针的概念，使创建复杂的数据结构和高效的API。托管语言使用的引用指针来代替，这是类似的，但添加自动解引用，并禁止指针运算，以消除某些类型的错误。他们仍然足够相似，但是，未能把握这一概念将反映在数据不佳，结构设计和错误的追溯之间的差异传递按值传递和按引用的方法调用。

症状

未能实现链表，或编写代码插入/删除的链接列表或树节点而不丢失数据
分配任意大阵列以可变长度的集合和维持一个独立的集合尺寸计数器，而不是使用一个动态数据结构
无法找到或修复的bug造成误用指针上执行算术
从指针传递作为参数传递给函数修改取消引用的值，而不是期待它的范围更改功能之外的值
制作一个指针的副本，通过副本改变取消引用的值，然后假设原来的指针仍然指向旧值
序列化一个指向磁盘或网络时，它应该已经提领值
通过进行对指针本身比较排序指针数组
补救措施

“我的一个朋友叫乔住在其他地方的酒店，我不知道他的房间号。但我确实知道哪个房间他相识，弗兰克住。所以我去了那里，敲他的门，问他，“哪里的乔住？”弗兰克不知道，但他知道哪个房间乔的同事，西奥多，住在，并给了我的房间号码来代替。于是我去了西奥多的房间，问他在哪里乔住，和西奥多告诉我，乔是在414房间，事实上，正是乔。“
指针可以与许多不同的隐喻，和数据结构进行描述成许多类比。以上是一个简单的比喻为一个链表，和任何人都可以创造自己，即使他们不是程序员。当指针被描述的理解故障不会发生，所以你不能任何更彻底地比他们已经被形容他们。它没有当程序员然后试图想象什么是在计算机的内存怎么回事，得到它与常规的变量，这是非常相似的理解混为一谈。它可以帮助将代码转换成一个简单的故事，以帮助推理是怎么回事，直到区分点击和程序员可以想像指针和数据结构，使他们直观地为作为标量值和数组。

5.通过难度看到递归

递归的想法是很容易理解，但程序员往往有想象一个递归操作在他们的心目中，或对复杂的结果可以用一个简单的函数来计算的结果问题。这使得它更难设计一个递归函数，因为你有“你在哪里”，当你来到编写测试的基本条件或者参数递归调用麻烦想象。

症状

可怕复杂的迭代算法的问题，可以递归来解决（例如：遍历文件树），尤其是内存和性能是不是溢价
递归函数之前和递归调用后检查相同的基本条件
递归函数不为基础条件测试
递归子程序串联/总和全局变量或随身携带以及输出变量
一下一下地作为参数传递的递归调用明显的混乱，或者说传递参数未修改的递归调用
认为迭代次数将被作为参数传递
补救措施

让你的脚湿，并为某些堆栈溢出做好准备。通过编写代码只有一个基本条件检查，并使用该传递相同的，未经修改的参数一递归调用开始。停止编码，即使你有，它是不够的感觉，并运行它无论如何。它抛出一个堆栈溢出异常，所以现在回去传递参数的修改副本递归调用。更多的堆栈溢出？过多的输出？然后做更多的代码和运行的迭代，从调整的基础条件测试，以调整你的递归调用切换，直到你开始直觉函数是如何转变其输入。抵制使用一个以上的基本条件测试或递归调用的冲动，除非你真的知道你在干什么。

你的目标是有信心跳，即使你没有一个完整意义上的“你在哪里”的虚递归路径。然后，当你需要编写一个函数，你会通过先写单元测试，并继续进行同样的技术上面开始一个真正的项目。

6.不信任的代码

症状

写作ISNULL（）和IsNotNull（），或IsTrue运算（布尔）和IsFalse（布尔）功能
检查是否一个布尔类型的变量是除true或false以外
补救措施

你所支付的行？你带过的老习惯从语言，具有弱类型的系统？如果没有，那么这个情况是类似的无力推理代码，但它似乎不是推理多数民众赞成受损，但信任和舒适性的语言。某些症状都比较喜欢的“舒适代码”，它无法生存逻辑分析，但程序员感到有必要这么写。唯一的补救方法可能有更多的时间来建立的熟悉。
你是个平庸的程序员迹象

1.无力，想套

从命令式编程的功能和声明式编程转换将立即要求你想想对数据集作为你的原始的，未标值的操作。每当你使用SQL和关系数据库的转变是必需的（而不是作为一个对象存储），只要你设计方案，将线性比例有多个处理器，每当你写的已经到了SIMD功能的芯片上执行代码（如作为现代的图形卡和视频游戏机）。

症状

下面的计数只有当他们在与程序员应该知道的声明或函数式编程功能的平台所看到的。

在集合内的元素或foreach循环执行原子操作
编写包含自己的循环，通过数据集迭代地图或缩小功能
中获取客户端从服务器和计算款项大型数据集，而不是使用聚合函数查询
作用于一个集合中的元素的功能，首先通过执行新的数据库查询来获取一个相关记录
编写业务逻辑函数的悲剧性影响的副作用，如更新的用户界面或执行文件I / O
打开自己的数据库连接或文件句柄，并保持通畅为每个对象的生命周期实体类
补救措施

够搞怪，可视卡经销商切割一副扑克牌，并通过他们与翻转他的拇指可以摇晃的胸怀融入想着集以及如何对它们在批量操作交错的两叠在一起。其他刺激可视化效果：

高速公路交通通过收费站的数组（并行处理）
弹簧连接，形成溪流加盟，形成小溪加盟，形成河流（平行减少/聚合函数）
报纸印刷机（协程，管道）
拉链标签上的外套拉拉链齿合（简单连接）
转移RNA拾取氨基酸和核糖体内接合信使RNA成为蛋白质（多级功能驱动联接，见动画）
上述同时发生在几十亿个细胞在橘树到空气，水和阳光转换成橙汁（的Map / Reduce在大型分布式集群）
如果您正在编写一个程序，用集合的作品，想想所有的补充数据和记录你的功能需要每个元素，并使用地图功能已应用到每对之前的Reduce函数将它们连接在一起成双成对。

2.缺乏批判性思维

除非你批评你自己的想法，并期待在自己的思维缺陷，你就会错过了可以固定之前，你甚至开始编码问题。如果你还不能批评你自己的代码写入一次，你只会在学习试错的大幅放缓。这个问题源于两个思想懒惰和以自我为中心的思想，所以其症状似乎来自两个不同的方向。

症状

自制“业务规则引擎”
脂肪静态实用工具类，或者只有一个命名空间的多学科库
砾岩应用程序，或附加功能无关到现有的应用程序，以避免启动一个新项目的开销
已开始要求本轮架构
加列表切线数据（例如：把你的地址簿表列中的“＃拥有汽车”）
不一致的命名约定
“人用锤子”的心态，或改变问题的定义，使他们能够与一个特定的技术都可以解决
那矮人，他们解决问题的复杂性节目
病理和冗余防御式编程（“Enterprisey代码”）
在XML重新发明LISP
补救措施

开始一本书像保罗批判性思维和长老，在控制你的自我的工作和实践抵制的冲动，保卫自己，你提交你的想法给朋友和同事的批评。

一旦你习惯了别人检查你的想法，开始审视自己的想法和自己想象练习他们的后果。此外，你还需要制定分寸（有一个感觉多少设计是适当的大小问题），实况检查假设的习惯（所以你不要高估问题的大小），以及对失败一个健康的心态（即使艾萨克·牛顿是错的引力，但我们仍然爱他，需要他想试试）。

最后，你必须有纪律。依据你的计划的瑕疵不会让你更有效率，除非你能拿出毅力来纠正并重新构建你的工作内容。

3.弹球编程

当你倾斜板恰到好处，回拉销到恰到好处的距离，并击中了鳍状肢按钮以正确的顺序，那么程序与执行反弹的条件和倒向奔向下一个状态转换选中流完美运行。

症状

一个try-catch块包装主（整个身体）和catch子句中的复位程序（弹球排水沟）
使用字符串/整型对于那些已经（或可给予）更合适的包装类型的值的强类型语言
包装复杂的数据转换成分隔字符串和解析它在使用它的每一个功能
没有使用的断言或合同法上采取模棱两可的输入功能
使用睡眠（）来等待另一个线程来完成其任务
开关不具有一个“，否则”子句上非枚举值语句
使用Automethods或反射调用被评为不合格用户的输入法
在设置功能全局变量的方式来返回多个值
有一种方法和一对夫妇领域，在那里你必须设置字段参数传递给方法的方式类
没有事务多行数据库更新
冰雹玛丽通行证（如：试图还原数据库的状态，没有交易和回滚）
补救措施

想象一下，你的程序的输入是水。这将告吹每道裂痕，并填写每一个口袋里，所以你需要想想后果是，当它流不到哪里您明确建立一些赶上它的地方等。

你需要让自己熟悉有助于使方案强大的韧性和你的平台上的机制。有三种基本类型：

那些任何损害之前停止该程序完成时，意想不到的事情发生了，然后帮助你确定哪些地方出了错（类型系统，断言，异常等），
那些直接程序流的任何代码的最佳处理应急（的try-catch块，多重调度，事件驱动编程等），
那些暂停线程，直到所有的鸭子都是在一排（最好推迟到命令，互斥和信号量，SyncLocks等）
还有第四个，单元测试，您在设计时使用。

使用这些应该成为你的第二天性，就像把逗号和句号的句子。为了达到这个目标，通过上述机制（那些括号中的一个）的时间和重构旧程序使用它们，无论你能填满它们，即使不变成是合适的（尤其是当他们穿上“牛逼似乎是适当，所以你也开始明白为什么）。

4.人生地不熟安全原则

如果出现以下症状​​不那么危险，他们会比大多数程序的问题适合正光洁度更小，这意味着他们不会让你一个坏的程序员，只是一个程序员谁不应该在网络程序的工作或安全系统，直到他做了一点功课。

症状

存储利用的信息（姓名，卡号，密码等）的明文
存储与无效的加密信息开发利用（对称密码编译到程序的密码;密码小事，任何“解码环”，自制的，专有的或未经证实的密码）
程序或设备，接受网络连接或口译输入来自不受信任来源之前不要限制自己的特权
不进行边界检查或输入验证，尤其是在使用非托管语言时
构建SQL查询通过字符串连接使用未经验证或转义输入
调用命名通过用户输入的程序
试图防止利用从工作通过搜索攻击的特征码
存储在一个无盐散列信用卡号码或密码
补救措施

以下内容仅包括基本原则，但他们会避免大多数的令人震惊的错误，以致危及整个系统。对于处理或储存的值信息给你或者它的用户，或者控制一个宝贵的资源任何系统中，始终有一个安全专业评审的设计和实施。

通过审核的程序进行存储输入数组或其他种类的分配内存的代码开始，并确保它会检查输入的大小不超过分配给存储它的内存。没有其他类的bug已经引起更多利用的安全漏洞比缓冲区溢出，并使得网络编写程序时，或任何安全是头等大事，你应该认真考虑内存管理语言的程度。

接下来，审计为串连未修改输入到一个SQL查询的身体，并切换到使用参数化查询，如果该平台支持的话，或者过滤数据库查询/逃避所有的输入，如果没有。这是为了防止SQL注入攻击。

你以后去毒牙安全漏洞的两个最臭名昭著的课程，你应该继续考虑所有的程序输入作为完全不值得信任的和潜在的恶意。重要的是要界定工作的验证码形式的程序的可接受的输入，和你的程序应该拒绝输入，除非它通过验证，这样就可以通过固定的验证，使之更具体的，而不是在扫描的签名修复利用的漏洞已知漏洞。

进一步说，你应该总是想想你的业务程序需要执行的权限它需要从主机做这些之前，你甚至开始设计它，因为这是要弄清楚如何将程序写入的最好机会用最少的权限可能。这背后的原理是，以限制可导致对系统的其余部分，如果可利用的错误已发现在代码中的损害。换句话说：你已经学会了不信任你输入后，你也应该学会不信任自己的程序。

你应该学会最后是加密的基础知识，具有Kerckhoff的原则开始。它可以表示为“安全应该是在关键的”，并且有几个有趣的点从它派生。

第一个是，你不应该相信一个密码或原始除非它被公开发表，并进行了分析，并通过更多安全社区广泛测试等加密。有默默无闻，专有或新奇没有安全，就进入密码。值得信赖的加密原语，甚至实现可以有瑕疵，所以要避免的实现不能确定已彻底审查（包括你自己）。所有新的密码系统进入审查的管道，可以是一个长达十年以上，并且要限制自己那些出来到底用他们所有的已知故障固定。

第二个是，如果密钥较弱，或存放不当，那么它的那么糟糕，因为有没有加密的。如果你的程序需要对数据进行加密，但不能解密，解密或者只在极少数情况下，再考虑用固定带好密码私钥单独给它的非对称密钥对的唯一公钥和制作解密阶段运行用户必须输入的每个时间。

更是岌岌可危，那么更多的功课，你需要做的，更多的还以为你必须投入项目的设计阶段，都因为安全是一个特点那几十个，有时会不请自来的数以百万计的人将试图打破后您的方案已经部署。

安全可追溯的故障代码，绝大多数是由于愚蠢的错误，其中大部分可避免通过筛选输入，采用保守的资源，使用常识，并编写代码没有速度比你能想到的和理性了。

5.代码是一个烂摊子

症状
不遵循一致的命名约定
不使用缩进，或使用不一致的缩进
不使用空白的其他地方，比如方法之间（或表达式，请参阅“ANDY = NO”）
大量代码留给注释掉
补救措施

在匆忙（或区域）的程序员犯下所有这些罪行，回来以后把它清理干净，但糟糕的程序员只是马虎。有时，它帮助使用可以修复缩进和空格（“漂亮的打印”）与快捷键的IDE，但我已经看到程序员谁，甚至可以通过与代码瞎搞太多打棍子Visual Studio的坚持正确的缩进。
迹象表明，你不应该是一个程序员

下面可能没有任何补救措施，如果你仍然从他们采取的编程课程在学校遭受之后，所以你将有更好的机会选择其他职业推进你的职业生涯。

1.无法确定程序执行的顺序

症状

1 = 5
B = 10
A = B

打印一
你看看上面的代码，而且不知道什么号码被打印出来，在最后
另类职业

电工
水管工人
建筑师
土木工程师
艺术家
抽象思维2.能力不足

症状

难点理解对象和类之间的区别
实施困难模式的设计为您的程序
难度编写函数低凝聚力
无能与正则表达式
Lisp是不透明的你
无法捉摸的教会图灵论题
另类职业

合同谈判
方法演员
3.哥烈兄弟综合征

症状

不愿扔掉任何东西，包括垃圾
不愿删除任何内容，无论是代码或评论
的冲动，建立诱杀装置，抵御入侵者
不愿与人沟通
可怜的组织能力
另类职业

古董商
包小姐
因果关系4.功能失调感

症状

你认真考虑恶意是一个原因，编译器会拒绝你的程序
在呼吁解决在部署程序中的错误，你试试祈祷
你理所当然采取隐变量和不三思指责他们为项目的行为不检
你觉得代码程序的存在会影响其运行时的行为，哪怕是永远不会调用*
你调试曲目包括像闪耀你的幸运高尔夫球，扭动你的结婚戒指，并敲击瞌睡狗玩具在显示器上的仪式。当调试不工作，你认为这可能是因为你错过了一个或没有做他们在正确的顺序
* - 内存的限制，转向偏移，和编译器的特殊性，尽管。看到在Reddit上的讨论。据此判断。
另类职业

玩老虎机在拉斯维加斯
Contrapositives
是什么让一个优秀的程序员通过凸轮Riely
5.冷漠与结果

编程可能仍然是一个爱好你，但它会在社会的最佳利益，对你进入专业的软件开发世界保卫自己。

症状

你不感兴趣的固定，可以通过重新启动计算机来工作围绕一个bug
您的安装程序静默部署是无关的你的不请自来的功能第三方程序*
设计用户界面，当你不使用任何符合人体工程学的模式，也不必在可用性研究的任何权益
你的程序具有预紧和宏伟超出了其效用，例如：显示启动画面过度活跃的程序在后台加载的同时，或将多个图标启动保费桌面位置*
你的程序产生的输出由另一个读取（例如：浏览器），或者实现了一个网络协议，并依靠对方的软件是显著容忍侵犯SPEC
你写的忙等待循环，即使该平台还提供事件驱动编程
你不使用托管语言，不能不屑于做的边界检查或输入验证
你的用户界面不会让意外调用比例函数其破坏性的困难（例如：“删除数据库”按钮旁边的“保存”，就那么大，没有确认步骤并没有撤消）
你不使用空格，缩进或意见
* - 这些实际上是由程序员，谁只实现他们往往比管理层强加的。我们还是将它们组合为求这种自我测试，不过，在最提示，一个一个更好的公司谋职，而其他可追溯到商学院学习赚取利润的破坏性较小的方式。

另类职业

讨债
电话销售
延伸阅读

这篇文章发表在黑客月刊，这不得不笔者写它的对立面的2012年5月发行（发行＃24）：你是一个优秀的程序员的迹象。
